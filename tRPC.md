# 相关基本理论知识

## RPC概念

### 什么是RPC

RPC(Remote Procedure Call Protocol) 远程过程调用协议。 一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。

要点：

1. 网络协议和网络IO模型对其透明：RPC的客户端认为自己在调用本地对象，那么传输层使用tcp/udp及应用层使用http或其他协议，客户端都不关心。那么调用过程中，使用哪一种网络IO模型调用者也不需要关心。
2. 信息格式对其透明：只关心对象调用传递的参数、返回的调用结果。对象内部如何计算，调用方不关心。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。
3. 应具备跨语言能力：调用方不清楚远程服务器使用何种语言。对于调用方来说，无论服务器使用何种语言都应调用成功，且返回值也应该按照调用方所理解的形式描述。

即在调用者看来自己就是在调用一个本地方法。

### RPC要素

![img](C:\Users\HUIYAN~1\AppData\Local\Temp\企业微信截图_16242726904242.png)

1. Client：协议调用方。实际情况下，Client需要制定RPC框架的一些细节。
2. Server:  指远程服务方法的具体实现（在JAVA中是RPC服务接口的具体实现）。接口实现类本身都不知道将被哪一个RPC远程客户端调用。
3. Stub/Proxy： RPC代理存在于客户端，负责管理消息格式、网络传输协议、判断调用过程是否正常。
4. Message Protocol： RPC的消息管理层专门对网络传输所承载的消息信息进行编号和解码操作。
5. Transfer/Network Protocol: 传输协议层负责管理RPC框架所使用的网络协议、网络IO模型。
6. Selector/Processor: 存在于RPC服务端，因服务端不知道自己是一个要被RPC提供给第三方系统调用的服务。因此RPC框架中需要“负责执行RPC接口实现”的角色。负责管理RPC接口注册、判断客户端请求权限、控制接口实现类的执行。
7. IDL: Interface description language接口定义语言。非必须，但跨语言的RPC框架需要。

### RPC框架的性能依据

1. 所支持的网络IO模型：在高并发状态下，会有很大差别。
2. 基于的网络协议：最终性能影响不大。
3. 选择的消息封装格式：考虑因素包括：消息易读性、描述单位内容时的消息体大小、编码难度、解码难度、解决半包/粘包问题的难易度。是性能差异的最重要原因。
4. 实现的服务处理管理方式：高并发请求下，是一个性能影响点。可以令Selector/Processor使用单个线程运行服务，也可以为每一个服务开启一个独立线程，也可以使用线程池。

## 术语介绍

### 1. 服务标识

客户端：主调（caller），RPC调用的发起者。

服务端：被调（callee），RPC服务的提供者。

#### 1.1 路由标识

RPC调用本质是一次网络通信的过程。从服务寻址角度来看，服务需要一个标识来获取服务地址，即**IP+端口+协议**。路由标识一般通过名字服务管理，也把它称为**服务名或Naming Service**。客户端通过路由标识向名字服务查询获取服务地址。

在PCG 123系统中，路由标识是由`.`号分割的四段字符串：`trpc.{app}.{server}.{service}`来表示。

app：应用名。通常表示某个业务系统名称。

server：提供服务的进程名称。一个server代表一个独立程序，绑定至少一个ip，实现至少一个service。

service：服务提供者，提供接口规范供客户端调用。每个server对应一个IP+端口+协议。

#### 1.2 接口标识

RPC调用接口也需要一个全局唯一标识，将它称为**接口标识或RPCName**,由`/{package}.{proto service}/{method}`三段组成。

package: 包名对应于protobuf中的package，可理解为一个支持多级的名字空间，用来防止接口命名冲突。

proto service：协议服务名，对应于protobuf中的service，是一组RPC方法的集合，是对接口的一个逻辑分组。一个server内允许定义多个proto service。

method: 方法或接口，对应于protobuf中的rpc方法，包括方法名称、请求和响应报文的参数类型。每个method有且仅有属于一个proto service，一个proto service允许定义多个method。

#### 1.3 接口映射

proto service负责定义RPC接口的定义和归类，naming service负责网络通信连接的建立，协议的处理。要将二者关联起来，通过把proto service注册到naming service来完成服务的组装。

单服务模式：基于微服务“单一原则”，建议一个服务端程序只提供一个proto service，对应一个naming service，通过一个端口对外提供接口服务。

单服务多协议模式：对于业务需要对一个服务通过多种协议提供服务的场景。例如: 一个认证服务需要通过http协议对外部系统提供认证服务，同时也需要通过tRPC协议对内部其它应用程序提供认证服务。

多服务多协议模式：每个proto service对应一个或者多个naming service，多个proto service之间不共享naming service。

#### 1.4 命名推荐

package的命名方式建议为：`trpc.{app}.{server}`，这样上游通过pb文件就能获知服务的路由名。

微服务：**一个服务只做一件事**。所以一个server最好只有一个service，建议proto service的命名和service保持一致。

### 2 . 路由寻址

tRPC框架不实现名字服务，会和名字服务密切交互。

![img](C:\Users\HUIYAN~1\AppData\Local\Temp\企业微信截图_16242756775228.png)

服务端提供服务时，告诉名字服务自己的服务名，服务端地址（IP+端口+协议）。还需要提供健康检查的机制来让名字服务监控服务的存货情况。

客户端调用服务的流程经过服务发现、服务路由、负载均衡和熔断四个模块，这四个模块的组合称为“**Selector**”。

1. 服务发现：客户端向名字服务提供指定服务名的地址，服务端返回所有可提供服务的服务端地址列表。
2. 服务路由：基于预先设定的策略，对名字服务返回的地址列表进行筛选，生成新的服务端地址列表。
3. 负载均衡：从满足本次转发要求的服务实例集中，通过一定负载均衡策略，选取一个实例供客户端进行服务请求发送。
4. 熔断：每个RPC请求的结果都会上报处理，熔断器根据上报情况决定是否对服务器节点进行熔断。





